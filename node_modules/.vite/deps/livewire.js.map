{
  "version": 3,
  "sources": ["browser-external:util", "browser-external:events", "../../highland/lib/index.js", "browser-external:url", "../../livewire/lib/compiler.js", "../../livewire/lib/respond.js", "../../livewire/lib/route.js", "../../livewire/lib/index.js"],
  "sourcesContent": ["module.exports = Object.create(new Proxy({}, {\n  get(_, key) {\n    if (\n      key !== '__esModule' &&\n      key !== '__proto__' &&\n      key !== 'constructor' &&\n      key !== 'splice'\n    ) {\n      console.warn(`Module \"util\" has been externalized for browser compatibility. Cannot access \"util.${key}\" in client code. See http://vitejs.dev/guide/troubleshooting.html#module-externalized-for-browser-compatibility for more details.`)\n    }\n  }\n}))", "module.exports = Object.create(new Proxy({}, {\n  get(_, key) {\n    if (\n      key !== '__esModule' &&\n      key !== '__proto__' &&\n      key !== 'constructor' &&\n      key !== 'splice'\n    ) {\n      console.warn(`Module \"events\" has been externalized for browser compatibility. Cannot access \"events.${key}\" in client code. See http://vitejs.dev/guide/troubleshooting.html#module-externalized-for-browser-compatibility for more details.`)\n    }\n  }\n}))", "/**\n * Highland: the high-level streams library\n *\n * Highland may be freely distributed under the Apache 2.0 license.\n * http://github.com/caolan/highland\n * Copyright (c) Caolan McMahon\n *\n */\n\n\nvar inherits = require('util').inherits;\nvar EventEmitter = require('events').EventEmitter;\n\n/**\n * The Stream constructor, accepts an array of values or a generator function\n * as an optional argument. This is typically the entry point to the Highland\n * APIs, providing a convenient way of chaining calls together.\n *\n * **Arrays -** Streams created from Arrays will emit each value of the Array\n * and then emit a [nil](#nil) value to signal the end of the Stream.\n *\n * **Generators -** These are functions which provide values for the Stream.\n * They are lazy and can be infinite, they can also be asynchronous (for\n * example, making a HTTP request). You emit values on the Stream by calling\n * `push(err, val)`, much like a standard Node.js callback. You call `next()`\n * to signal you've finished processing the current data. If the Stream is\n * still being consumed the generator function will then be called again.\n *\n * You can also redirect a generator Stream by passing a new source Stream\n * to read from to next. For example: `next(other_stream)` - then any subsequent\n * calls will be made to the new source.\n *\n * **Node Readable Stream -** Pass in a Node Readable Stream object to wrap\n * it with the Highland API. Reading from the resulting Highland Stream will\n * begin piping the data from the Node Stream to the Highland Stream.\n *\n * **EventEmitter / jQuery Elements -** Pass in both an event name and an\n * event emitter as the two arguments to the constructor and the first\n * argument emitted to the event handler will be written to the new Stream.\n *\n * You can also pass as an optional third parameter a function, an array of strings\n * or a number. In this case the event handler will try to wrap the arguments emitted\n * to it and write this object to the new stream.\n *\n * **Promise -** Accepts an ES6 / jQuery style promise and returns a\n * Highland Stream which will emit a single value (or an error).\n *\n * @id _(source)\n * @section Stream Objects\n * @name _(source)\n * @param {Array | Function | Readable Stream | Promise} source - (optional) source to take values from from\n * @api public\n *\n * // from an Array\n * _([1, 2, 3, 4]);\n *\n * // using a generator function\n * _(function (push, next) {\n *     push(null, 1);\n *     push(err);\n *     next();\n * });\n *\n * // a stream with no source, can pipe node streams through it etc.\n * var through = _();\n *\n * // wrapping a Node Readable Stream so you can easily manipulate it\n * _(readable).filter(hasSomething).pipe(writeable);\n *\n * // creating a stream from events\n * _('click', btn).each(handleEvent);\n *\n * // creating a stream from events with mapping\n * _('request', httpServer, ['req', 'res']).each(handleEvent);\n *\n * // from a Promise object\n * var foo = _($.getJSON('/api/foo'));\n */\n\nexports = module.exports = function (/*optional*/xs, /*optional*/ee, /*optional*/ mappingHint) {\n    return new Stream(xs, ee, mappingHint);\n};\n\nvar _ = exports;\n\n\n// Save bytes in the minified (but not gzipped) version:\nvar ArrayProto = Array.prototype,\n    ObjProto = Object.prototype;\n\n// Create quick reference variables for speed access to core prototypes.\nvar slice = ArrayProto.slice,\n    toString = ObjProto.toString;\n\n\n_.isFunction = function (x) {\n    return typeof x === 'function';\n};\n\n_.isObject = function (x) {\n    return typeof x === 'object' && x !== null;\n};\n\n_.isString = function (x) {\n    return typeof x === 'string';\n};\n\n_.isArray = Array.isArray || function (x) {\n    return toString.call(x) === '[object Array]';\n};\n\n// setImmediate implementation with browser and older node fallbacks\nif (typeof setImmediate === 'undefined') {\n    if (typeof process === 'undefined' || !(process.nextTick)) {\n        _.setImmediate = function (fn) {\n            setTimeout(fn, 0);\n        };\n    }\n    else {\n        // use nextTick on old node versions\n        _.setImmediate = process.nextTick;\n    }\n}\n// check no process.stdout to detect browserify\nelse if (typeof process === 'undefined' || !(process.stdout)) {\n    // modern browser - but not a direct alias for IE10 compatibility\n    _.setImmediate = function (fn) {\n        setImmediate(fn);\n    };\n}\nelse {\n    _.setImmediate = setImmediate;\n}\n\n\n/**\n * The end of stream marker. This is sent along the data channel of a Stream\n * to tell consumers that the Stream has ended. See the example map code for\n * an example of detecting the end of a Stream.\n *\n * Note: `nil` is setup as a global where possible. This makes it convenient\n * to access, but more importantly lets Streams from different Highland\n * instances work together and detect end-of-stream properly. This is mostly\n * useful for NPM where you may have many different Highland versions installed.\n *\n * @id nil\n * @section Utils\n * @name _.nil\n * @api public\n *\n * var map = function (iter, source) {\n *     return source.consume(function (err, val, push, next) {\n *         if (err) {\n *             push(err);\n *             next();\n *         }\n *         else if (val === _.nil) {\n *             push(null, val);\n *         }\n *         else {\n *             push(null, iter(val));\n *             next();\n *         }\n *     });\n * };\n */\n\n// set up a global nil object in cases where you have multiple Highland\n// instances installed (often via npm)\nvar _global = this;\nif (typeof global !== 'undefined') {\n    _global = global;\n}\nelse if (typeof window !== 'undefined') {\n    _global = window;\n}\nif (!_global.nil) {\n    _global.nil = {};\n}\nvar nil = _.nil = _global.nil;\n\n/**\n * Transforms a function with specific arity (all arguments must be\n * defined) in a way that it can be called as a chain of functions until\n * the arguments list is saturated.\n *\n * This function is not itself curryable.\n *\n * @id curry\n * @name curry(fn, [*arguments])\n * @section Functions\n * @param {Function} fn - the function to curry\n * @param args.. - any number of arguments to pre-apply to the function\n * @returns Function\n * @api public\n *\n * fn = curry(function (a, b, c) {\n *     return a + b + c;\n * });\n *\n * fn(1)(2)(3) == fn(1, 2, 3)\n * fn(1, 2)(3) == fn(1, 2, 3)\n * fn(1)(2, 3) == fn(1, 2, 3)\n */\n\n_.curry = function (fn /* args... */) {\n    var args = slice.call(arguments);\n    return _.ncurry.apply(this, [fn.length].concat(args));\n};\n\n/**\n * Same as `curry` but with a specific number of arguments. This can be\n * useful when functions do not explicitly define all its parameters.\n *\n * This function is not itself curryable.\n *\n * @id ncurry\n * @name ncurry(n, fn, [args...])\n * @section Functions\n * @param {Number} n - the number of arguments to wait for before apply fn\n * @param {Function} fn - the function to curry\n * @param args... - any number of arguments to pre-apply to the function\n * @returns Function\n * @api public\n *\n * fn = ncurry(3, function () {\n *     return Array.prototype.join.call(arguments, '.');\n * });\n *\n * fn(1, 2, 3) == '1.2.3';\n * fn(1, 2)(3) == '1.2.3';\n * fn(1)(2)(3) == '1.2.3';\n */\n\n_.ncurry = function (n, fn /* args... */) {\n    var largs = slice.call(arguments, 2);\n    if (largs.length >= n) {\n        return fn.apply(this, largs.slice(0, n));\n    }\n    return function () {\n        var args = largs.concat(slice.call(arguments));\n        if (args.length < n) {\n            return _.ncurry.apply(this, [n, fn].concat(args));\n        }\n        return fn.apply(this, args.slice(0, n));\n    };\n};\n\n/**\n * Partially applies the function (regardless of whether it has had curry\n * called on it). This will always postpone execution until at least the next\n * call of the partially applied function.\n *\n * @id partial\n * @name partial(fn, args...)\n * @section Functions\n * @param {Function} fn - function to partial apply\n * @param args... - the arguments to apply to the function\n * @api public\n *\n * var addAll = function () {\n *     var args = Array.prototype.slice.call(arguments);\n *     return foldl1(add, args);\n * };\n * var f = partial(addAll, 1, 2);\n * f(3, 4) == 10\n */\n\n_.partial = function (f /* args... */) {\n    var args = slice.call(arguments, 1);\n    return function () {\n        return f.apply(this, args.concat(slice.call(arguments)));\n    };\n};\n\n/**\n * Evaluates the function `fn` with the argument positions swapped. Only\n * works with functions that accept two arguments.\n *\n * @id flip\n * @name flip(fn, [x, y])\n * @section Functions\n * @param {Function} f - function to flip argument application for\n * @param x - parameter to apply to the right hand side of f\n * @param y - parameter to apply to the left hand side of f\n * @api public\n *\n * div(2, 4) == 0.5\n * flip(div, 2, 4) == 2\n * flip(div)(2, 4) == 2\n */\n\n_.flip = _.curry(function (fn, x, y) { return fn(y, x); });\n\n/**\n * Creates a composite function, which is the application of function1 to\n * the results of function2. You can pass an arbitrary number of arguments\n * and have them composed. This means you can't partially apply the compose\n * function itself.\n *\n * @id compose\n * @name compose(fn1, fn2, ...)\n * @section Functions\n * @api public\n *\n * var add1 = add(1);\n * var mul3 = mul(3);\n *\n * var add1mul3 = compose(mul3, add1);\n * add1mul3(2) == 9\n */\n\n_.compose = function (/*functions...*/) {\n    var fns = slice.call(arguments).reverse();\n    return _.seq.apply(null, fns);\n};\n\n/**\n * The reversed version of compose. Where arguments are in the order of\n * application.\n *\n * @id seq\n * @name seq(fn1, fn2, ...)\n * @section Functions\n * @api public\n *\n * var add1 = add(1);\n * var mul3 = mul(3);\n *\n * var add1mul3 = seq(add1, mul3);\n * add1mul3(2) == 9\n */\n\n_.seq = function () {\n    var fns = slice.call(arguments);\n    return function () {\n        if (!fns.length) {\n            return;\n        }\n        var r = fns[0].apply(this, arguments);\n        for (var i = 1; i < fns.length; i++) {\n            r = fns[i].call(this, r);\n        }\n        return r;\n    };\n};\n\n/**\n * Actual Stream constructor wrapped the the main exported function\n */\n\nfunction Stream(/*optional*/xs, /*optional*/ee, /*optional*/mappingHint) {\n    if (xs && _.isStream(xs)) {\n        // already a Stream\n        return xs;\n    }\n\n    EventEmitter.call(this);\n    var self = this;\n\n    // used to detect Highland Streams using isStream(x), this\n    // will work even in cases where npm has installed multiple\n    // versions, unlike an instanceof check\n    self.__HighlandStream__ = true;\n\n    self.id = ('' + Math.random()).substr(2, 6);\n    this.paused = true;\n    this._incoming = [];\n    this._outgoing = [];\n    this._consumers = [];\n    this._observers = [];\n    this._destructors = [];\n    this._send_events = false;\n    this._delegate = null;\n    this.source = null;\n\n    // Old-style node Stream.pipe() checks for this\n    this.writable = true;\n\n    self.on('newListener', function (ev) {\n        if (ev === 'data') {\n            self._send_events = true;\n            _.setImmediate(self.resume.bind(self));\n        }\n        else if (ev === 'end') {\n            // this property avoids us checking the length of the\n            // listners subscribed to each event on each _send() call\n            self._send_events = true;\n        }\n    });\n\n    // TODO: write test to cover this removeListener code\n    self.on('removeListener', function (ev) {\n        if (ev === 'end' || ev === 'data') {\n            var end_listeners = self.listeners('end').length;\n            var data_listeners = self.listeners('data').length;\n            if (end_listeners + data_listeners === 0) {\n                // stop emitting events\n                self._send_events = false;\n            }\n        }\n    });\n\n    if (xs === undefined) {\n        // nothing else to do\n    }\n    else if (_.isArray(xs)) {\n        self._incoming = xs.concat([nil]);\n    }\n    else if (typeof xs === 'function') {\n        this._generator = xs;\n        this._generator_push = function (err, x) {\n            self.write(err ? new StreamError(err): x);\n        };\n        this._generator_next = function (s) {\n            if (s) {\n                // we MUST pause to get the redirect object into the _incoming\n                // buffer otherwise it would be passed directly to _send(),\n                // which does not handle StreamRedirect objects!\n                var _paused = self.paused;\n                if (!_paused) {\n                    self.pause();\n                }\n                self.write(new StreamRedirect(s));\n                if (!_paused) {\n                    self.resume();\n                }\n            }\n            else {\n                self._generator_running = false;\n            }\n            if (!self.paused) {\n                self.resume();\n            }\n        };\n    }\n    else if (_.isObject(xs)) {\n        if (_.isFunction(xs.then)) {\n            // probably a promise\n            return _(function (push) {\n                xs.then(function (value) {\n                    push(null, value);\n                    return push(null, nil);\n                },\n                function (err) {\n                    push(err);\n                    return push(null, nil);\n                });\n            });\n        }\n        else {\n            // write any errors into the stream\n            xs.on('error', function (err) {\n                self.write(new StreamError(err));\n            });\n            // assume it's a pipeable stream as a source\n            xs.pipe(self);\n        }\n    }\n    else if (typeof xs === 'string') {\n        var mappingHintType = (typeof mappingHint);\n        var mapper;\n\n        if (mappingHintType === 'function') {\n            mapper = mappingHint;\n        } else if (mappingHintType === 'number') {\n            mapper = function () {\n                return slice.call(arguments, 0, mappingHint);\n            };\n        } else if (_.isArray(mappingHint)) {\n            mapper = function () {\n                var args = arguments;\n                return mappingHint.reduce(function (ctx, hint, idx) {\n                    ctx[hint] = args[idx];\n                    return ctx;\n                }, {});\n            };\n        } else {\n            mapper = function (x) { return x; };\n        }\n\n        ee.on(xs, function () {\n            var ctx = mapper.apply(this, arguments);\n            self.write(ctx);\n        });\n    }\n    else {\n        throw new Error(\n            'Unexpected argument type to Stream(): ' + (typeof xs)\n        );\n    }\n}\ninherits(Stream, EventEmitter);\n\n/**\n * adds a top-level _.foo(mystream) style export for Stream methods\n */\n\nfunction exposeMethod(name) {\n    var f = Stream.prototype[name];\n    var n = f.length;\n    _[name] = _.ncurry(n + 1, function () {\n        var args = Array.prototype.slice.call(arguments);\n        var s = _(args.pop());\n        return f.apply(s, args);\n    });\n}\n\n/**\n * Used as an Error marker when writing to a Stream's incoming buffer\n */\n\nfunction StreamError(err) {\n    this.__HighlandStreamError__ = true;\n    this.error = err;\n}\n\n/**\n * Used as a Redirect marker when writing to a Stream's incoming buffer\n */\n\nfunction StreamRedirect(to) {\n    this.__HighlandStreamRedirect__ = true;\n    this.to = to;\n}\n\n/**\n * Returns true if `x` is a Highland Stream.\n *\n * @id isStream\n * @section Utils\n * @name _.isStream(x)\n * @param x - the object to test\n * @api public\n *\n * _.isStream('foo')  // => false\n * _.isStream(_([1,2,3]))  // => true\n */\n\n_.isStream = function (x) {\n    return _.isObject(x) && x.__HighlandStream__;\n};\n\n_._isStreamError = function (x) {\n    return _.isObject(x) && x.__HighlandStreamError__;\n};\n\n_._isStreamRedirect = function (x) {\n    return _.isObject(x) && x.__HighlandStreamRedirect__;\n};\n\n/**\n * Sends errors / data to consumers, observers and event handlers\n */\n\nStream.prototype._send = function (err, x) {\n    if (x === nil) {\n        this.ended = true;\n    }\n    if (this._consumers.length) {\n        for (var i = 0, len = this._consumers.length; i < len; i++) {\n            var c = this._consumers[i];\n            if (err) {\n                c.write(new StreamError(err));\n            }\n            else {\n                c.write(x);\n            }\n        }\n    }\n    if (this._observers.length) {\n        for (var j = 0, len2 = this._observers.length; j < len2; j++) {\n            this._observers[j].write(x);\n        }\n    }\n    if (this._send_events) {\n        if (x === nil) {\n            this.emit('end');\n        }\n        else {\n            this.emit('data', x);\n        }\n    }\n};\n\n/**\n * Pauses the stream. All Highland Streams start in the paused state.\n *\n * @id pause\n * @section Stream Objects\n * @name Stream.pause()\n * @api public\n *\n * var xs = _(generator);\n * xs.pause();\n */\n\nStream.prototype.pause = function () {\n    //console.log([this.id, 'pause']);\n    this.paused = true;\n    if (this.source) {\n        this.source._checkBackPressure();\n    }\n};\n\n/**\n * When there is a change in downstream consumers, it will often ask\n * the parent Stream to re-check it's state and pause/resume accordingly.\n */\n\nStream.prototype._checkBackPressure = function () {\n    if (!this._consumers.length) {\n        return this.pause();\n    }\n    for (var i = 0, len = this._consumers.length; i < len; i++) {\n        if (this._consumers[i].paused) {\n            return this.pause();\n        }\n    }\n    return this.resume();\n};\n\n/**\n * Starts pull values out of the incoming buffer and sending them downstream,\n * this will exit early if this causes a downstream consumer to pause.\n */\n\nStream.prototype._readFromBuffer = function () {\n    var len = this._incoming.length;\n    var i = 0;\n    while (i < len && !this.paused) {\n        var x = this._incoming[i];\n        if (_._isStreamError(x)) {\n            this._send(x.error);\n        }\n        else if (_._isStreamRedirect(x)) {\n            this._redirect(x.to);\n        }\n        else {\n            this._send(null, x);\n        }\n        i++;\n    }\n    // remove processed data from _incoming buffer\n    this._incoming.splice(0, i);\n};\n\n/**\n * Starts pull values out of the incoming buffer and sending them downstream,\n * this will exit early if this causes a downstream consumer to pause.\n */\n\nStream.prototype._sendOutgoing = function () {\n    var len = this._outgoing.length;\n    var i = 0;\n    while (i < len && !this.paused) {\n        var x = this._outgoing[i];\n        if (_._isStreamError(x)) {\n            Stream.prototype._send.call(this, x.error);\n        }\n        else if (_._isStreamRedirect(x)) {\n            this._redirect(x.to);\n        }\n        else {\n            Stream.prototype._send.call(this, null, x);\n        }\n        i++;\n    }\n    // remove processed data from _outgoing buffer\n    this._outgoing.splice(0, i);\n};\n\n/**\n * Resumes a paused Stream. This will either read from the Stream's incoming\n * buffer or request more data from an upstream source.\n *\n * @id resume\n * @section Stream Objects\n * @name Stream.resume()\n * @api public\n *\n * var xs = _(generator);\n * xs.resume();\n */\n\nStream.prototype.resume = function () {\n    //console.log([this.id, 'resume']);\n    if (this._resume_running) {\n        // already processing _incoming buffer, ignore resume call\n        this._repeat_resume = true;\n        return;\n    }\n    this._resume_running = true;\n    do {\n        // use a repeat flag to avoid recursing resume() calls\n        this._repeat_resume = false;\n        this.paused = false;\n\n        // send values from outgoing buffer first\n        this._sendOutgoing();\n\n        // send values from incoming buffer before reading from source\n        this._readFromBuffer();\n\n        // we may have paused while reading from buffer\n        if (!this.paused) {\n            // ask parent for more data\n            if (this.source) {\n                this.source._checkBackPressure();\n            }\n            // run _generator to fill up _incoming buffer\n            else if (this._generator) {\n                this._runGenerator();\n            }\n            else {\n                // perhaps a node stream is being piped in\n                this.emit('drain');\n            }\n        }\n    } while (this._repeat_resume);\n    this._resume_running = false;\n};\n\n/**\n * Ends a Stream. This is the same as sending a [nil](#nil) value as data.\n * You shouldn't need to call this directly, rather it will be called by\n * any [Node Readable Streams](http://nodejs.org/api/stream.html#stream_class_stream_readable)\n * you pipe in.\n *\n * @id end\n * @section Stream Objects\n * @name Stream.end()\n * @api public\n *\n * mystream.end();\n */\n\nStream.prototype.end = function () {\n    this.write(nil);\n};\n\n/**\n * Pipes a Highland Stream to a [Node Writable Stream](http://nodejs.org/api/stream.html#stream_class_stream_writable)\n * (Highland Streams are also Node Writable Streams). This will pull all the\n * data from the source Highland Stream and write it to the destination,\n * automatically managing flow so that the destination is not overwhelmed\n * by a fast source.\n *\n * This function returns the destination so you can chain together pipe calls.\n *\n * @id pipe\n * @section Consumption\n * @name Stream.pipe(dest)\n * @param {Writable Stream} dest - the destination to write all data to\n * @api public\n *\n * var source = _(generator);\n * var dest = fs.createWriteStream('myfile.txt')\n * source.pipe(dest);\n *\n * // chained call\n * source.pipe(through).pipe(dest);\n */\n\nStream.prototype.pipe = function (dest) {\n    var self = this;\n\n    // stdout and stderr are special case writables that cannot be closed\n    var canClose = dest !== process.stdout && dest !== process.stderr;\n\n    var s = self.consume(function (err, x, push, next) {\n        if (err) {\n            self.emit('error', err);\n            return;\n        }\n        if (x === nil) {\n            if (canClose) {\n                dest.end();\n            }\n        }\n        else if (dest.write(x) !== false) {\n            next();\n        }\n    });\n\n    dest.on('drain', onConsumerDrain);\n\n    // Since we don't keep a reference to piped-to streams,\n    // save a callback that will unbind the event handler.\n    this._destructors.push(function () {\n        dest.removeListener('drain', onConsumerDrain);\n    });\n\n    s.resume();\n    return dest;\n\n    function onConsumerDrain() {\n        s.resume();\n    }\n};\n\n/**\n * Destroys a stream by unlinking it from any consumers and sources. This will\n * stop all consumers from receiving events from this stream and removes this\n * stream as a consumer of any source stream.\n *\n * This function calls end() on the stream and unlinks it from any piped-to streams.\n *\n * @id destroy\n * @section Stream Objects\n * @name Stream.destroy()\n * @api public\n */\n\nStream.prototype.destroy = function () {\n    var self = this;\n    this.end();\n    _(this._consumers).each(function (consumer) {\n        self._removeConsumer(consumer);\n    });\n    if (this.source) {\n        this.source._removeConsumer(this);\n    }\n    _(this._destructors).each(function (destructor) {\n        destructor();\n    });\n};\n\n/**\n * Runs the generator function for this Stream. If the generator is already\n * running (it has been called and not called next() yet) then this function\n * will do nothing.\n */\n\nStream.prototype._runGenerator = function () {\n    // if _generator already running, exit\n    if (this._generator_running) {\n        return;\n    }\n    this._generator_running = true;\n    this._generator(this._generator_push, this._generator_next);\n};\n\n/**\n * Performs the redirect from one Stream to another. In order for the\n * redirect to happen at the appropriate time, it is put on the incoming\n * buffer as a StreamRedirect object, and this function is called\n * once it is read from the buffer.\n */\n\nStream.prototype._redirect = function (to) {\n    // coerce to Stream\n    to = _(to);\n\n    while (to._delegate) {\n        to = to._delegate;\n    }\n\n    to._consumers = this._consumers.map(function (c) {\n        c.source = to;\n        return c;\n    });\n    // TODO: copy _observers\n    this._consumers = [];\n    this.consume = function () {\n        return to.consume.apply(to, arguments);\n    };\n    this._removeConsumer = function () {\n        return to._removeConsumer.apply(to, arguments);\n    };\n    if (this.paused) {\n        to.pause();\n    }\n    else {\n        this.pause();\n        to._checkBackPressure();\n    }\n\n    this._delegate = to;\n};\n\n/**\n * Adds a new consumer Stream, which will accept data and provide backpressure\n * to this Stream. Adding more than one consumer will cause an exception to be\n * thrown as the backpressure strategy must be explicitly chosen by the\n * developer (through calling fork or observe).\n */\n\nStream.prototype._addConsumer = function (s) {\n    if (this._consumers.length) {\n        throw new Error(\n            'Stream already being consumed, you must either fork() or observe()'\n        );\n    }\n    s.source = this;\n    this._consumers.push(s);\n    this._checkBackPressure();\n};\n\n/**\n * Removes a consumer from this Stream.\n */\n\nStream.prototype._removeConsumer = function (s) {\n    this._consumers = this._consumers.filter(function (c) {\n        return c !== s;\n    });\n    if (s.source === this) {\n        s.source = null;\n    }\n    this._checkBackPressure();\n};\n\n/**\n * Consumes values from a Stream (once resumed) and returns a new Stream for\n * you to optionally push values onto using the provided push / next functions.\n *\n * This function forms the basis of many higher-level Stream operations.\n * It will not cause a paused stream to immediately resume, but behaves more\n * like a 'through' stream, handling values as they are read.\n *\n * @id consume\n * @section Transforms\n * @name Stream.consume(f)\n * @param {Function} f - the function to handle errors and values\n * @api public\n *\n * var filter = function (f, source) {\n *     return source.consume(function (err, x, push, next) {\n *         if (err) {\n *             // pass errors along the stream and consume next value\n *             push(err);\n *             next();\n *         }\n *         else if (x === _.nil) {\n *             // pass nil (end event) along the stream\n *             push(null, x);\n *         }\n *         else {\n *             // pass on the value only if the value passes the predicate\n *             if (f(x)) {\n *                 push(null, x);\n *             }\n *             next();\n *         }\n *     });\n * };\n */\n\nStream.prototype.consume = function (f) {\n    var self = this;\n    var s = new Stream();\n    var _send = s._send;\n    var push = function (err, x) {\n        //console.log(['push', err, x, s.paused]);\n        if (x === nil) {\n            // ended, remove consumer from source\n            self._removeConsumer(s);\n        }\n        if (s.paused) {\n            if (err) {\n                s._outgoing.push(new StreamError(err));\n            }\n            else {\n                s._outgoing.push(x);\n            }\n        }\n        else {\n            _send.call(s, err, x);\n        }\n    };\n    var async;\n    var next_called;\n    var next = function (s2) {\n        //console.log(['next', async]);\n        if (s2) {\n            // we MUST pause to get the redirect object into the _incoming\n            // buffer otherwise it would be passed directly to _send(),\n            // which does not handle StreamRedirect objects!\n            var _paused = s.paused;\n            if (!_paused) {\n                s.pause();\n            }\n            s.write(new StreamRedirect(s2));\n            if (!_paused) {\n                s.resume();\n            }\n        }\n        else if (async) {\n            s.resume();\n        }\n        else {\n            next_called = true;\n        }\n    };\n    s._send = function (err, x) {\n        async = false;\n        next_called = false;\n        f(err, x, push, next);\n        async = true;\n        if (!next_called) {\n            s.pause();\n        }\n    };\n    self._addConsumer(s);\n    return s;\n};\n\n/**\n * Consumes a single item from the Stream. Unlike consume, this function will\n * not provide a new stream for you to push values onto, and it will unsubscribe\n * as soon as it has a single error, value or nil from the source.\n *\n * You probably won't need to use this directly, but it is used internally by\n * some functions in the Highland library.\n *\n * @id pull\n * @section Consumption\n * @name Stream.pull(f)\n * @param {Function} f - the function to handle data\n * @api public\n *\n * xs.pull(function (err, x) {\n *     // do something\n * });\n */\n\nStream.prototype.pull = function (f) {\n    var s = this.consume(function (err, x) {\n        s.source._removeConsumer(s);\n        f(err, x);\n    });\n    s.resume();\n};\n\n/**\n * Writes a value to the Stream. If the Stream is paused it will go into the\n * Stream's incoming buffer, otherwise it will be immediately processed and\n * sent to the Stream's consumers (if any). Returns false if the Stream is\n * paused, true otherwise. This lets Node's pipe method handle back-pressure.\n *\n * You shouldn't need to call this yourself, but it may be called by Node\n * functions which treat Highland Streams as a [Node Writable Stream](http://nodejs.org/api/stream.html#stream_class_stream_writable).\n *\n * @id write\n * @section Stream Objects\n * @name Stream.write(x)\n * @param x - the value to write to the Stream\n * @api public\n *\n * var xs = _();\n * xs.write(1);\n * xs.write(2);\n * xs.end();\n *\n * xs.toArray(function (ys) {\n *     // ys will be [1, 2]\n * });\n */\n\nStream.prototype.write = function (x) {\n    if (this.paused) {\n        this._incoming.push(x);\n    }\n    else {\n        if (_._isStreamError(x)) {\n            this._send(x.error);\n        }\n        else {\n            this._send(null, x);\n        }\n    }\n    return !this.paused;\n};\n\n/**\n * Forks a stream, allowing you to add additional consumers with shared\n * back-pressure. A stream forked to multiple consumers will only pull values\n * from it's source as fast as the slowest consumer can handle them.\n *\n * @id fork\n * @section Higher-order Streams\n * @name Stream.fork()\n * @api public\n *\n * var xs = _([1, 2, 3, 4]);\n * var ys = xs.fork();\n * var zs = xs.fork();\n *\n * // no values will be pulled from xs until zs also resume\n * ys.resume();\n *\n * // now both ys and zs will get values from xs\n * zs.resume();\n */\n\nStream.prototype.fork = function () {\n    var s = new Stream();\n    s.id = 'fork:' + s.id;\n    s.source = this;\n    this._consumers.push(s);\n    this._checkBackPressure();\n    return s;\n};\n\n/**\n * Observes a stream, allowing you to handle values as they are emitted, without\n * adding back-pressure or causing data to be pulled from the source. This can\n * be useful when you are performing two related queries on a stream where one\n * would block the other. Just be aware that a slow observer could fill up it's\n * buffer and cause memory issues. Where possible, you should use [fork](#fork).\n *\n * @id observe\n * @section Higher-order Streams\n * @name Stream.observe()\n * @api public\n *\n * var xs = _([1, 2, 3, 4]);\n * var ys = xs.fork();\n * var zs = xs.observe();\n *\n * // now both zs and ys will recieve data as fast as ys can handle it\n * ys.resume();\n */\n\nStream.prototype.observe = function () {\n    var s = new Stream();\n    s.id = 'observe:' + s.id;\n    s.source = this;\n    this._observers.push(s);\n    return s;\n};\n\n/**\n * Extracts errors from a Stream and applies them to an error handler\n * function. Returns a new Stream with the errors removed (unless the error\n * handler chooses to rethrow them using `push`). Errors can also be\n * transformed and put back onto the Stream as values.\n *\n * @id errors\n * @section Transforms\n * @name Stream.errors(f)\n * @param {Function} f - the function to pass all errors to\n * @api public\n *\n * getDocument.errors(function (err, push) {\n *     if (err.statusCode === 404) {\n *         // not found, return empty doc\n *         push(null, {});\n *     }\n *     else {\n *         // otherwise, re-throw the error\n *         push(err);\n *     }\n * });\n */\n\nStream.prototype.errors = function (f) {\n    return this.consume(function (err, x, push, next) {\n        if (err) {\n            f(err, push);\n            next();\n        }\n        else if (x === nil) {\n            push(null, nil);\n        }\n        else {\n            push(null, x);\n            next();\n        }\n    });\n};\nexposeMethod('errors');\n\n/**\n * Like the [errors](#errors) method, but emits a Stream end marker after\n * an Error is encountered.\n *\n * @id stopOnError\n * @section Transforms\n * @name Stream.stopOnError(f)\n * @param {Function} f - the function to handle an error\n * @api public\n *\n * brokenStream.stopOnError(function (err) {\n *     console.error('Something broke: ' + err);\n * });\n */\n\nStream.prototype.stopOnError = function (f) {\n    return this.consume(function (err, x, push, next) {\n        if (err) {\n            f(err, push);\n            push(null, nil);\n        }\n        else if (x === nil) {\n            push(null, nil);\n        }\n        else {\n            push(null, x);\n            next();\n        }\n    });\n};\nexposeMethod('stopOnError');\n\n/**\n * Iterates over every value from the Stream, calling the iterator function\n * on each of them. This function causes a **thunk**.\n *\n * If an error from the Stream reaches the `each` call, it will emit an\n * error event (which will cause it to throw if unhandled).\n *\n * @id each\n * @section Consumption\n * @name Stream.each(f)\n * @param {Function} f - the iterator function\n * @api public\n *\n * _([1, 2, 3, 4]).each(function (x) {\n *     // will be called 4 times with x being 1, 2, 3 and 4\n * });\n */\n\nStream.prototype.each = function (f) {\n    var self = this;\n    return this.consume(function (err, x, push, next) {\n        if (err) {\n            self.emit('error', err);\n        }\n        else if (x !== nil) {\n            f(x);\n            next();\n        }\n    }).resume();\n};\nexposeMethod('each');\n\n/**\n * Applies results from a Stream as arguments to a function\n *\n * @id apply\n * @section Consumption\n * @name Stream.apply(f)\n * @param {Function} f - the function to apply arguments to\n * @api public\n *\n * _([1, 2, 3]).apply(function (a, b, c) {\n *     // a === 1\n *     // b === 2\n *     // c === 3\n * });\n */\n\nStream.prototype.apply = function (f) {\n    return this.toArray(function (args) {\n        f.apply(null, args);\n    });\n};\nexposeMethod('apply');\n\n/**\n * Collects all values from a Stream into an Array and calls a function with\n * once with the result. This function causes a **thunk**.\n *\n * If an error from the Stream reaches the `toArray` call, it will emit an\n * error event (which will cause it to throw if unhandled).\n *\n * @id toArray\n * @section Consumption\n * @name Stream.toArray(f)\n * @param {Function} f - the callback to provide the completed Array to\n * @api public\n *\n * _([1, 2, 3, 4]).toArray(function (x) {\n *     // parameter x will be [1,2,3,4]\n * });\n */\n\n// TODO: implement using collect()?\nStream.prototype.toArray = function (f) {\n    var self = this;\n    var xs = [];\n    return this.consume(function (err, x, push, next) {\n        if (err) {\n            self.emit('error', err);\n        }\n        else if (x === nil) {\n            f(xs);\n        }\n        else {\n            xs.push(x);\n            next();\n        }\n    }).resume();\n};\n\n/**\n * Creates a new Stream of transformed values by applying a function to each\n * value from the source. The transformation function can be replaced with\n * a non-function value for convenience, and it will emit that value\n * for every data event on the source Stream.\n *\n * @id map\n * @section Transforms\n * @name Stream.map(f)\n * @param f - the transformation function or value to map to\n * @api public\n *\n * var doubled = _([1, 2, 3, 4]).map(function (x) {\n *     return x * 2;\n * });\n *\n * _([1, 2, 3]).map('hi')  // => 'hi', 'hi', 'hi'\n */\n\nStream.prototype.map = function (f) {\n    if (!_.isFunction(f)) {\n        var val = f;\n        f = function () {\n            return val;\n        };\n    }\n    return this.consume(function (err, x, push, next) {\n        if (err) {\n            push(err);\n            next();\n        }\n        else if (x === nil) {\n            push(err, x);\n        }\n        else {\n            var fnVal, fnErr;\n            try {\n                fnVal = f(x);\n            } catch (e) {\n                fnErr = e;\n            }\n            push(fnErr, fnVal);\n            next();\n        }\n    });\n};\nexposeMethod('map');\n\n/**\n * Creates a new Stream which applies a function to each value from the source\n * and re-emits the source value. Useful when you want to mutate the value or\n * perform side effects\n *\n * @id doto\n * @section Transforms\n * @name Stream.doto(f)\n * @param f - the function to apply\n * @api public\n *\n * var appended = _([[1], [2], [3], [4]]).doto(function (x) {\n *     x.push(1);\n * });\n *\n * _([1, 2, 3]).doto(console.log)\n * // 1\n * // 2\n * // 3\n * // => 1, 2, 3\n */\n\nStream.prototype.doto = function (f) {\n    return this.map(function (x) {\n        f(x);\n        return x;\n    });\n};\nexposeMethod('doto');\n\n/**\n * Creates a new Stream of values by applying each item in a Stream to an\n * iterator function which must return a (possibly empty) Stream. Each item on\n * these result Streams are then emitted on a single output Stream.\n *\n * @id flatMap\n * @section Higher-order Streams\n * @name Stream.flatMap(f)\n * @param {Function} f - the iterator function\n * @api public\n *\n * filenames.flatMap(readFile)\n */\n\nStream.prototype.flatMap = function (f) {\n    return this.map(f).sequence();\n};\nexposeMethod('flatMap');\n\n/**\n * Retrieves values associated with a given property from all elements in\n * the collection.\n *\n * @id pluck\n * @section Transforms\n * @name Stream.pluck(property)\n * @param {String} prop - the property to which values should be associated\n * @api public\n *\n * var docs = [\n *     {type: 'blogpost', title: 'foo'},\n *     {type: 'blogpost', title: 'bar'},\n *     {type: 'comment', title: 'baz'}\n * ];\n *\n * _(docs).pluck('title').toArray(function (xs) {\n *    // xs is now ['foo', 'bar', 'baz']\n * });\n */\n\nStream.prototype.pluck = function (prop) {\n    return this.consume(function (err, x, push, next) {\n        if (err) {\n            push(err);\n            next();\n        }\n        else if (x === nil) {\n            push(err, x);\n        }\n        else if (_.isObject(x)) {\n            push(null, x[prop]);\n            next();\n        }\n        else {\n            push(new Error(\n                'Expected Object, got ' + (typeof x)\n            ));\n            next();\n        }\n    });\n};\nexposeMethod('pluck');\n\n/**\n * Creates a new Stream including only the values which pass a truth test.\n *\n * @id filter\n * @section Transforms\n * @name Stream.filter(f)\n * @param f - the truth test function\n * @api public\n *\n * var evens = _([1, 2, 3, 4]).filter(function (x) {\n *     return x % 2 === 0;\n * });\n */\n\nStream.prototype.filter = function (f) {\n    return this.consume(function (err, x, push, next) {\n        if (err) {\n            push(err);\n            next();\n        }\n        else if (x === nil) {\n            push(err, x);\n        }\n        else {\n            var fnVal, fnErr;\n            try {\n                fnVal = f(x);\n            } catch (e) {\n                fnErr = e;\n            }\n\n            if (fnErr) {\n                push(fnErr);\n            } else if (fnVal) {\n                push(null, x);\n            }\n            next();\n        }\n    });\n};\nexposeMethod('filter');\n\n/**\n * Filters using a predicate which returns a Stream. If you need to check\n * against an asynchronous data source when filtering a Stream, this can\n * be convenient. The Stream returned from the filter function should have\n * a Boolean as it's first value (all other values on the Stream will be\n * disregarded).\n *\n * @id flatFilter\n * @section Higher-order Streams\n * @name Stream.flatFilter(f)\n * @param {Function} f - the truth test function which returns a Stream\n * @api public\n *\n * var checkExists = _.wrapCallback(fs.exists);\n * filenames.flatFilter(checkExists)\n */\n\nStream.prototype.flatFilter = function (f) {\n    return this.flatMap(function (x) {\n        return f(x).take(1).otherwise(errorStream())\n        .flatMap(function (bool) {\n            return _(bool ? [x] : []);\n        });\n    });\n\n    function errorStream() {\n        return _(function (push) {\n            push(new Error('Stream returned by function was empty.'));\n            push(null, _.nil);\n        });\n    }\n};\nexposeMethod('flatFilter');\n\n/**\n * The inverse of [filter](#filter).\n *\n * @id reject\n * @section Transforms\n * @name Stream.reject(f)\n * @param {Function} f - the truth test function\n * @api public\n *\n * var odds = _([1, 2, 3, 4]).reject(function (x) {\n *     return x % 2 === 0;\n * });\n */\n\nStream.prototype.reject = function (f) {\n    return this.filter(_.compose(_.not, f));\n};\nexposeMethod('reject');\n\n/**\n * A convenient form of filter, which returns the first object from a\n * Stream that passes the provided truth test\n *\n * @id find\n * @section Transforms\n * @name Stream.find(f)\n * @param {Function} f - the truth test function which returns a Stream\n * @api public\n *\n * var docs = [\n *     {type: 'blogpost', title: 'foo'},\n *     {type: 'blogpost', title: 'bar'},\n *     {type: 'comment', title: 'foo'}\n * ];\n *\n * var f = function (x) {\n *     return x.type == 'blogpost';\n * };\n *\n * _(docs).find(f);\n * // => [{type: 'blogpost', title: 'foo'}]\n *\n * // example with partial application\n * var firstBlogpost = _.find(f);\n *\n * firstBlogpost(docs)\n * // => [{type: 'blogpost', title: 'foo'}]\n */\n\nStream.prototype.find = function (f) {\n    return this.filter(f).take(1);\n};\nexposeMethod('find');\n\n/**\n * A convenient form of reduce, which groups items based on a function or property name\n *\n * @id group\n * @section Transforms\n * @name Stream.group(f)\n * @param {Function|String} f - the function or property name on which to group,\n *                              toString() is called on the result of a function.\n * @api public\n *\n * var docs = [\n *     {type: 'blogpost', title: 'foo'},\n *     {type: 'blogpost', title: 'bar'},\n *     {type: 'comment', title: 'foo'}\n * ];\n *\n * var f = function (x) {\n *     return x.type;\n * };\n *\n * _(docs).group(f); OR _(docs).group('type');\n * // => {\n * // =>    'blogpost': [{type: 'blogpost', title: 'foo'}, {type: 'blogpost', title: 'bar'}]\n * // =>    'comment': [{type: 'comment', title: 'foo'}]\n * // =>  }\n *\n */\n\nStream.prototype.group = function (f) {\n    var lambda = _.isString(f) ? _.get(f) : f;\n    return this.reduce({}, function (m, o) {\n        var key = lambda(o);\n        if (!m.hasOwnProperty(key)) { m[key] = []; }\n        m[key].push(o);\n        return m;\n    }.bind(this));\n};\nexposeMethod('group');\n\n/**\n * Filters a Stream to drop all non-truthy values.\n *\n * @id compact\n * @section Transforms\n * @name Stream.compact()\n * @api public\n *\n * var compacted = _([0, 1, false, 3, null, undefined, 6]).compact();\n * // => [1, 3, 6]\n */\n\nStream.prototype.compact = function () {\n    return this.filter(function (x) {\n        return x;\n    });\n};\nexposeMethod('compact');\n\n/**\n * A convenient form of filter, which returns all objects from a Stream\n * match a set of property values.\n *\n * @id where\n * @section Transforms\n * @name Stream.where(props)\n * @param {Object} props - the properties to match against\n * @api public\n *\n * var docs = [\n *     {type: 'blogpost', title: 'foo'},\n *     {type: 'blogpost', title: 'bar'},\n *     {type: 'comment', title: 'foo'}\n * ];\n *\n * _(docs).where({title: 'foo'})\n * // => {type: 'blogpost', title: 'foo'}\n * // => {type: 'comment', title: 'foo'}\n *\n * // example with partial application\n * var getBlogposts = _.where({type: 'blogpost'});\n *\n * getBlogposts(docs)\n * // => {type: 'blogpost', title: 'foo'}\n * // => {type: 'blogpost', title: 'bar'}\n */\n\nStream.prototype.where = function (props) {\n    return this.filter(function (x) {\n        for (var k in props) {\n            if (x[k] !== props[k]) {\n                return false;\n            }\n        }\n        return true;\n    });\n};\nexposeMethod('where');\n\n/**\n * Takes two Streams and returns a Stream of corresponding pairs.\n *\n * @id zip\n * @section Higher-order Streams\n * @name Stream.zip(ys)\n * @param {Array | Stream} ys - the other stream to combine values with\n * @api public\n *\n * _(['a', 'b', 'c']).zip([1, 2, 3])  // => ['a', 1], ['b', 2], ['c', 3]\n */\n\nStream.prototype.zip = function (ys) {\n    ys = _(ys);\n    var xs = this;\n    var returned = 0;\n    var z = [];\n    function nextValue(index, max, src, push, next) {\n        src.pull(function (err, x) {\n            if (err) {\n                push(err);\n                nextValue(index, max, src, push, next);\n            }\n            else if (x === _.nil) {\n                push(null, nil);\n            }\n            else {\n                returned++;\n                z[index] = x;\n                if (returned === max) {\n                    push(null, z);\n                    next();\n                }\n            }\n        });\n    }\n    return _(function (push, next) {\n        returned = 0;\n        z = [];\n        nextValue(0, 2, xs, push, next);\n        nextValue(1, 2, ys, push, next);\n    });\n};\nexposeMethod('zip');\n\n/**\n * Takes one Stream and batches incoming data into arrays of given length\n *\n * @id batch\n * @section Transforms\n * @name Stream.batch(n)\n * @param {Number} n - length of the array to batch\n * @api public\n *\n * _([1, 2, 3, 4, 5]).batch(2)  // => [1, 2], [3, 4], [5]\n */\n\nStream.prototype.batch = function (n) {\n    var batched = [];\n\n    return this.consume(function (err, x, push, next) {\n        if (err) {\n            push(err);\n            next();\n        }\n        if (x === nil) {\n            if (batched.length > 0) {\n                push(null, batched);\n            }\n\n            push(null, nil);\n        } else {\n            batched.push(x);\n\n            if (batched.length === n) {\n                push(null, batched);\n                batched = [];\n            }\n\n            next();\n        }\n    });\n};\nexposeMethod('batch');\n\n/**\n * Creates a new Stream with the first `n` values from the source.\n *\n * @id take\n * @section Transforms\n * @name Stream.take(n)\n * @param {Number} n - integer representing number of values to read from source\n * @api public\n *\n * _([1, 2, 3, 4]).take(2) // => 1, 2\n */\n\nStream.prototype.take = function (n) {\n    if (n === 0) {\n        return _([]);\n    }\n    return this.consume(function (err, x, push, next) {\n        if (err) {\n            push(err);\n            if (n > 0) {\n                next();\n            }\n            else {\n                push(null, nil);\n            }\n        }\n        else if (x === nil) {\n            push(null, nil);\n        }\n        else {\n            n--;\n            push(null, x);\n            if (n > 0) {\n                next();\n            }\n            else {\n                push(null, nil);\n            }\n        }\n    });\n};\nexposeMethod('take');\n\n/**\n * Creates a new Stream with only the first value from the source.\n *\n * @id head\n * @section Transforms\n * @name Stream.head()\n * @api public\n *\n * _([1, 2, 3, 4]).head() // => 1\n */\n\nStream.prototype.head = function () {\n    return this.take(1);\n};\nexposeMethod('head');\n\n/**\n * Drops all values from the Stream apart from the last one (if any).\n *\n * @id last\n * @section Transforms\n * @name Stream.last()\n * @api public\n *\n * _([1, 2, 3, 4]).last()  // => 4\n */\n\nStream.prototype.last = function () {\n    var nothing = {};\n    var prev = nothing;\n    return this.consume(function (err, x, push, next) {\n        if (err) {\n            push(err);\n            next();\n        }\n        else if (x === nil) {\n            if (prev !== nothing) {\n                push(null, prev);\n            }\n            push(null, nil);\n        }\n        else {\n            prev = x;\n            next();\n        }\n    });\n};\nexposeMethod('last');\n\n/**\n * Passes the current Stream to a function, returning the result. Can also\n * be used to pipe the current Stream through another Stream. It will always\n * return a Highland Stream (instead of the piped to target directly as in\n * Node.js).\n *\n * @id through\n * @section Higher-order Streams\n * @name Stream.through(target)\n * @api public\n *\n * function oddDoubler(s) {\n *     return s.filter(function (x) {\n *         return x % 2; // odd numbers only\n *     })\n *     .map(function (x) {\n *         return x * 2;\n *     });\n * }\n *\n * _([1, 2, 3, 4]).through(oddDoubler).toArray(function (xs) {\n *     // xs will be [2, 6]\n * });\n *\n * // Can also be used with Node Through Streams\n * _(filenames).through(jsonParser).map(function (obj) {\n *     // ...\n * });\n */\n\nStream.prototype.through = function (target) {\n    if (_.isFunction(target)) {\n        return target(this);\n    }\n    else {\n        var output = _();\n        target.pause();\n        this.pipe(target).pipe(output);\n        return output;\n    }\n};\nexposeMethod('through');\n\n/**\n * Creates a 'Through Stream', which passes data through a pipeline\n * of functions or other through Streams. This is particularly useful\n * when combined with partial application of Highland functions to expose a\n * Node-compatible Through Stream.\n *\n * This is not a method on a Stream, and it only exposed at the top-level\n * as `_.pipeline`. It takes an arbitrary number of arguments.\n *\n * @id pipeline\n * @section Higher-order Streams\n * @name _.pipeline(...)\n * @api public\n *\n * var through = _.pipeline(\n *     _.map(parseJSON),\n *     _.filter(isBlogpost),\n *     _.reduce(collectCategories)\n *     _.through(otherPipeline)\n * );\n *\n * readStream.pipe(through).pipe(outStream);\n *\n * // Alternatively, you can use pipeline to manipulate a stream in\n * // the chained method call style:\n *\n * var through2 = _.pipeline(function (s) {\n *     return s.map(parseJSON).filter(isBlogpost); // etc.\n * });\n */\n\n_.pipeline = function (/*through...*/) {\n    if (!arguments.length) {\n        return _();\n    }\n    var start = arguments[0], rest;\n    if (!_.isStream(start) && !_.isFunction(start.resume)) {\n        // not a Highland stream or Node stream, start with empty stream\n        start = _();\n        rest = slice.call(arguments);\n    }\n    else {\n        // got a stream as first argument, co-erce to Highland stream\n        start = _(start);\n        rest = slice.call(arguments, 1);\n    }\n    var end = rest.reduce(function (src, dest) {\n        return src.through(dest);\n    }, start);\n    var wrapper = _(function (push, next) {\n        end.pull(function (err, x) {\n            if (err) {\n                wrapper._send(err);\n                next();\n            }\n            else if (x === nil) {\n                wrapper._send(null, nil);\n            }\n            else {\n                wrapper._send(null, x);\n                next();\n            }\n        });\n    });\n    wrapper.write = function (x) {\n        start.write(x);\n    };\n    return wrapper;\n};\n\n/**\n * Reads values from a Stream of Streams, emitting them on a Single output\n * Stream. This can be thought of as a flatten, just one level deep. Often\n * used for resolving asynchronous actions such as a HTTP request or reading\n * a file.\n *\n * @id sequence\n * @section Higher-order Streams\n * @name Stream.sequence()\n * @api public\n *\n * var nums = _([\n *     _([1, 2, 3]),\n *     _([4, 5, 6])\n * ]);\n *\n * nums.sequence()  // => 1, 2, 3, 4, 5, 6\n *\n * // using sequence to read from files in series\n * filenames.map(readFile).sequence()\n */\n\nStream.prototype.sequence = function () {\n    var original = this;\n    var curr = this;\n    return _(function (push, next) {\n        curr.pull(function (err, x) {\n            if (err) {\n                push(err);\n                return next();\n            }\n            else if (_.isArray(x)) {\n                if (onOriginalStream()) {\n                    // just send all values from array directly\n                    x.forEach(function (y) {\n                        push(null, y);\n                    });\n                } else {\n                    push(null, x);\n                }\n                return next();\n            }\n            else if (_.isStream(x)) {\n                if (onOriginalStream()) {\n                    // switch to reading new stream\n                    curr = x;\n                    return next();\n                }\n                else {\n                    // sequence only goes 1 level deep\n                    push(null, x);\n                    return next();\n                }\n            }\n            else if (x === nil) {\n                if (onOriginalStream()) {\n                    push(null, nil);\n                }\n                else {\n                    // resume reading from original\n                    curr = original;\n                    return next();\n                }\n            }\n            else {\n                if (onOriginalStream()) {\n                    // we shouldn't be getting non-stream (or array)\n                    // values from the top-level stream\n                    push(new Error(\n                        'Expected Stream, got ' + (typeof x)\n                    ));\n                    return next();\n                }\n                else {\n                    push(null, x);\n                    return next();\n                }\n            }\n        });\n    });\n\n    function onOriginalStream() {\n        return curr === original;\n    }\n};\nexposeMethod('sequence');\n\n/**\n * An alias for the [sequence](#sequence) method.\n *\n * @id series\n * @section Higher-order Streams\n * @name Stream.series()\n * @api public\n *\n * filenames.map(readFile).series()\n */\n\nStream.prototype.series = Stream.prototype.sequence;\n_.series = _.sequence;\n\n/**\n * Recursively reads values from a Stream which may contain nested Streams\n * or Arrays. As values or errors are encountered, they are emitted on a\n * single output Stream.\n *\n * @id flatten\n * @section Higher-order Streams\n * @name Stream.flatten()\n * @api public\n *\n * _([1, [2, 3], [[4]]]).flatten();  // => 1, 2, 3, 4\n *\n * var nums = _(\n *     _([1, 2, 3]),\n *     _([4, _([5, 6]) ])\n * );\n *\n * nums.flatten();  // => 1, 2, 3, 4, 5, 6\n */\n\nStream.prototype.flatten = function () {\n    var curr = this;\n    var stack = [];\n    return _(function (push, next) {\n        curr.pull(function (err, x) {\n            if (err) {\n                push(err);\n                return next();\n            }\n            if (_.isArray(x)) {\n                x = _(x);\n            }\n            if (_.isStream(x)) {\n                stack.push(curr);\n                curr = x;\n                next();\n            }\n            else if (x === nil) {\n                if (stack.length) {\n                    curr = stack.pop();\n                    next();\n                }\n                else {\n                    push(null, nil);\n                }\n            }\n            else {\n                push(null, x);\n                next();\n            }\n        });\n    });\n};\nexposeMethod('flatten');\n\n/**\n * Takes a Stream of Streams and reads from them in parallel, buffering\n * the results until they can be returned to the consumer in their original\n * order.\n *\n * @id parallel\n * @section Higher-order Streams\n * @name Stream.parallel(n)\n * @param {Number} n - the maximum number of concurrent reads/buffers\n * @api public\n *\n * var readFile = _.wrapCallback(fs.readFile);\n * var filenames = _(['foo.txt', 'bar.txt', 'baz.txt']);\n *\n * // read from up to 10 files at once\n * filenames.map(readFile).parallel(10);\n */\n\nStream.prototype.parallel = function (n) {\n    var buffers = [];\n    var running = 0;\n    var self = this;\n    var ondata = null;\n    return _(function (push, next) {\n        ondata = null;\n        // make sure we're reading from 'n' streams\n        var len = buffers.length;\n        if (!self.ended && running < n) {\n            var i = 0;\n            self.take(n - running).each(function (x) {\n                running++;\n                var target = buffers[len + i] = [];\n                i++;\n                x.consume(function (err, x, _push, _next) {\n                    if (x === nil) {\n                        running--;\n                        target.push([null, nil]);\n                    }\n                    else {\n                        target.push([err, x]);\n                        _next();\n                    }\n                    if (target === buffers[0] && ondata) {\n                        ondata();\n                    }\n                }).resume();\n            });\n        }\n        // check if we have buffered data we can send\n        if (buffers.length) {\n            if (buffers[0].length) {\n                var args = buffers[0].shift();\n                var err = args[0];\n                var x = args[1];\n                if (x === nil) {\n                    // stream finished, move on to next one\n                    buffers.shift();\n                }\n                else {\n                    push(err, x);\n                }\n                next();\n            }\n            else {\n                // waiting for more data from first stream\n                ondata = function () {\n                    ondata = null;\n                    next();\n                };\n            }\n        }\n        else if (self.ended && running === 0) {\n            // totally done\n            push(null, nil);\n            return;\n        }\n        else {\n            // waiting for more streams to read\n            ondata = function () {\n                ondata = null;\n                next();\n            };\n        }\n    });\n};\nexposeMethod('parallel');\n\n/**\n * Switches source to an alternate Stream if the current Stream is empty.\n *\n * @id otherwise\n * @section Higher-order Streams\n * @name Stream.otherwise(ys)\n * @param {Stream} ys - alternate stream to use if this stream is empty\n * @api public\n *\n * _([1,2,3]).otherwise(['foo'])  // => 1, 2, 3\n * _([]).otherwise(['foo'])       // => 'foo'\n *\n * _.otherwise(_(['foo']), _([1,2,3]))    // => 1, 2, 3\n * _.otherwise(_(['foo']), _([]))         // => 'foo'\n */\n\nStream.prototype.otherwise = function (ys) {\n    var xs = this;\n    return xs.consume(function (err, x, push, next) {\n        if (err) {\n            // got an error, just keep going\n            push(err);\n            next();\n        }\n        if (x === nil) {\n            // hit the end without redirecting to xs, use alternative\n            next(ys);\n        }\n        else {\n            // got a value, push it, then redirect to xs\n            push(null, x);\n            next(xs);\n        }\n    });\n};\nexposeMethod('otherwise');\n\n/**\n * Adds a value to the end of a Stream.\n *\n * @id append\n * @section Transforms\n * @name Stream.append(y)\n * @param y - the value to append to the Stream\n * @api public\n *\n * _([1, 2, 3]).append(4)  // => 1, 2, 3, 4\n */\n\nStream.prototype.append = function (y) {\n    return this.consume(function (err, x, push, next) {\n        if (x === nil) {\n            push(null, y);\n            push(null, _.nil);\n        }\n        else {\n            push(err, x);\n            next();\n        }\n    });\n};\nexposeMethod('append');\n\n/**\n * Boils down a Stream to a single value. The memo is the initial state\n * of the reduction, and each successive step of it should be returned by\n * the iterator function. The iterator is passed two arguments:\n * the memo and the next value.\n *\n * If the iterator throws an error, the reduction stops and the resulting\n * stream will emit that error instead of a value.\n *\n * @id reduce\n * @section Transforms\n * @name Stream.reduce(memo, iterator)\n * @param memo - the initial state of the reduction\n * @param {Function} iterator - the function which reduces the values\n * @api public\n *\n * var add = function (a, b) {\n *     return a + b;\n * };\n *\n * _([1, 2, 3, 4]).reduce(0, add)  // => 10\n */\n\nStream.prototype.reduce = function (z, f) {\n    // This can't be implemented with scan(), because we don't know if the\n    // errors that we see from the scan were thrown by the iterator or just\n    // passed through from the source stream.\n    return this.consume(function (err, x, push, next) {\n        if (x === nil) {\n            push(null, z);\n            push(null, _.nil);\n        }\n        else if (err) {\n            push(err);\n            next();\n        }\n        else {\n            try {\n                z = f(z, x);\n            } catch (e) {\n                push(e);\n                push(null, _.nil);\n                return;\n            }\n\n            next();\n        }\n    });\n};\nexposeMethod('reduce');\n\n/**\n * Same as [reduce](#reduce), but uses the first element as the initial\n * state instead of passing in a `memo` value.\n *\n * @id reduce1\n * @section Transforms\n * @name Stream.reduce1(iterator)\n * @param {Function} iterator - the function which reduces the values\n * @api public\n *\n * _([1, 2, 3, 4]).reduce1(add)  // => 10\n */\n\nStream.prototype.reduce1 = function (f) {\n    var self = this;\n    return _(function (push, next) {\n        self.pull(function (err, x) {\n            if (err) {\n                push(err);\n                next();\n            }\n            if (x === nil) {\n                push(null, nil);\n            }\n            else {\n                next(self.reduce(x, f));\n            }\n        });\n    });\n};\nexposeMethod('reduce1');\n\n/**\n * Groups all values into an Array and passes down the stream as a single\n * data event. This is a bit like doing [toArray](#toArray), but instead\n * of accepting a callback and causing a *thunk*, it passes the value on.\n *\n * @id collect\n * @section Transforms\n * @name Stream.collect()\n * @api public\n *\n * _(['foo', 'bar']).collect().toArray(function (xs) {\n *     // xs will be [['foo', 'bar']]\n * });\n */\n\nStream.prototype.collect = function () {\n    var xs = [];\n    return this.consume(function (err, x, push, next) {\n        if (err) {\n            push(err);\n            next();\n        }\n        else if (x === nil) {\n            push(null, xs);\n            push(null, nil);\n        }\n        else {\n            xs.push(x);\n            next();\n        }\n    });\n};\nexposeMethod('collect');\n\n/**\n * Like [reduce](#reduce), but emits each intermediate value of the\n * reduction as it is calculated.\n *\n * If the iterator throws an error, the scan will stop and the stream will\n * emit that error. Any intermediate values that were produced before the\n * error will still be emitted.\n *\n * @id scan\n * @section Transforms\n * @name Stream.scan(memo, iterator)\n * @param memo - the initial state of the reduction\n * @param {Function} iterator - the function which reduces the values\n * @api public\n *\n * _([1, 2, 3, 4]).scan(0, add)  // => 0, 1, 3, 6, 10\n */\n\nStream.prototype.scan = function (z, f) {\n    var self = this;\n    return _([z]).concat(\n        self.consume(function (err, x, push, next) {\n            if (x === nil) {\n                push(null, _.nil);\n            }\n            else if (err) {\n                push(err);\n                next();\n            }\n            else {\n                try {\n                    z = f(z, x);\n                } catch (e) {\n                    push(e);\n                    push(null, _.nil);\n                    return;\n                }\n\n                push(null, z);\n                next();\n            }\n        })\n    );\n};\nexposeMethod('scan');\n\n/**\n * Same as [scan](#scan), but uses the first element as the initial\n * state instead of passing in a `memo` value.\n *\n * @id scan1\n * @section Transforms\n * @name Stream.scan1(iterator)\n * @param {Function} iterator - the function which reduces the values\n * @api public\n *\n * _([1, 2, 3, 4]).scan1(add)  // => 1, 3, 6, 10\n */\n\nStream.prototype.scan1 = function (f) {\n    var self = this;\n    return _(function (push, next) {\n        self.pull(function (err, x) {\n            if (err) {\n                push(err);\n                next();\n            }\n            if (x === nil) {\n                push(null, nil);\n            }\n            else {\n                next(self.scan(x, f));\n            }\n        });\n    });\n};\nexposeMethod('scan1');\n\n/**\n * Concatenates a Stream to the end of this Stream.\n *\n * Be aware that in the top-level export, the args may be in the reverse\n * order to what you'd expect `_([a], [b]) => [b, a]`, as this follows the\n * convention of other top-level exported functions which do `x` to `y`.\n *\n * @id concat\n * @section Higher-order Streams\n * @name Stream.concat(ys)\n * @params {Stream | Array} ys - the values to concatenate onto this Stream\n * @api public\n *\n * _([1, 2]).concat([3, 4])  // => 1, 2, 3, 4\n * _.concat([3, 4], [1, 2])  // => 1, 2, 3, 4\n */\n\nStream.prototype.concat = function (ys) {\n    ys = _(ys);\n    return this.consume(function (err, x, push, next) {\n        if (x === nil) {\n            next(ys);\n        }\n        else {\n            push(err, x);\n            next();\n        }\n    });\n};\nexposeMethod('concat');\n\n/**\n * Takes a Stream of Streams and merges their values and errors into a\n * single new Stream. The merged stream ends when all source streams have\n * ended.\n *\n * Note that no guarantee is made with respect to the order in which\n * values for each stream end up in the merged stream. Values in the\n * merged stream will, however, respect the order they were emitted from\n * their respective streams.\n *\n * @id merge\n * @section Higher-order Streams\n * @name Stream.merge()\n * @api public\n *\n * var txt = _(['foo.txt', 'bar.txt']).map(readFile)\n * var md = _(['baz.md']).map(readFile)\n *\n * _([txt, md]).merge();\n * // => contents of foo.txt, bar.txt and baz.txt in the order they were read\n */\n\nStream.prototype.merge = function () {\n    var self = this;\n    var ended = 0;\n    var total = 0;\n    var toread = [];\n    var reading_srcs = false;\n    return _(function (push, next) {\n        if (!self.ended && !reading_srcs) {\n            reading_srcs = true;\n            self.pull(function (err, x) {\n                if (err) {\n                    push(err);\n                }\n                else if (x !== nil) {\n                    total++;\n                    toread.push(x);\n                }\n                reading_srcs = false;\n                next();\n            });\n        }\n        while (toread.length) {\n            (function (src) {\n                src.pull(function (err, x) {\n                    if (err) {\n                        toread.push(src);\n                        push(err);\n                        next();\n                    }\n                    else if (x === nil) {\n                        ended++;\n                        if (self.ended && ended === total) {\n                            push(null, nil);\n                        }\n                        else {\n                            next();\n                        }\n                    }\n                    else {\n                        toread.push(src);\n                        push(null, x);\n                        next();\n                    }\n                });\n            })(toread.shift());\n        }\n    });\n};\nexposeMethod('merge');\n\n/**\n * Calls a named method on each object from the Stream - returning\n * a new stream with the result of those calls.\n *\n * @id invoke\n * @section Transforms\n * @name Stream.invoke(method, args)\n * @param {String} method - the method name to call\n * @param {Array} args - the arguments to call the method with\n * @api public\n *\n * _(['foo', 'bar']).invoke('toUpperCase', [])  // => FOO, BAR\n *\n * filenames.map(readFile).sequence().invoke('toString', ['utf8']);\n */\n\nStream.prototype.invoke = function (method, args) {\n    return this.map(function (x) {\n        return x[method].apply(x, args);\n    });\n};\nexposeMethod('invoke');\n\n/**\n * Ensures that only one data event is push downstream (or into the buffer)\n * every `ms` milliseconds, any other values are dropped.\n *\n * @id throttle\n * @section Transforms\n * @name Stream.throttle(ms)\n * @param {Number} ms - the minimum milliseconds between each value\n * @api public\n *\n * _('mousemove', document).throttle(1000);\n */\n\nStream.prototype.throttle = function (ms) {\n    var s = new Stream();\n    var last = 0 - ms;\n    var _write = s.write;\n    s.write = function (x) {\n        var now = new Date().getTime();\n        if (_._isStreamError(x) || x === nil) {\n            return _write.apply(this, arguments);\n        }\n        else if (now - ms >= last) {\n            last = now;\n            return _write.apply(this, arguments);\n        }\n    };\n    this._addConsumer(s);\n    return s;\n};\nexposeMethod('throttle');\n\n/**\n * Holds off pushing data events downstream until there has been no more\n * data for `ms` milliseconds. Sends the last value that occurred before\n * the delay, discarding all other values.\n *\n * @id debounce\n * @section Transforms\n * @name Stream.debounce(ms)\n * @param {Number} ms - the milliseconds to wait before sending data\n * @api public\n *\n * // sends last keyup event after user has stopped typing for 1 second\n * $('keyup', textbox).debounce(1000);\n */\n\nStream.prototype.debounce = function (ms) {\n    var s = new Stream();\n    var t = null;\n    var nothing = {};\n    var last = nothing;\n    var _write = s.write;\n    s.write = function (x) {\n        if (_._isStreamError(x)) {\n            // let errors through regardless\n            return _write.apply(this, arguments);\n        }\n        else if (x === nil) {\n            if (t) {\n                clearTimeout(t);\n            }\n            if (last !== nothing) {\n                _write.call(s, last);\n            }\n            return _write.apply(this, arguments);\n        }\n        else {\n            last = x;\n            if (t) {\n                clearTimeout(t);\n            }\n            t = setTimeout(function () {\n                _write.call(s, last);\n            }, ms);\n            return !this.paused;\n        }\n    };\n    this._addConsumer(s);\n    return s;\n};\nexposeMethod('debounce');\n\n/**\n * Creates a new Stream, which when read from, only returns the last\n * seen value from the source. The source stream does not experience\n * back-pressure. Useful if you're using a Stream to model a changing\n * property which you need to query periodically.\n *\n * @id latest\n * @section Transforms\n * @name Stream.latest()\n * @api public\n *\n * // slowThing will always get the last known mouse position\n * // when it asks for more data from the mousePosition stream\n * mousePosition.latest().map(slowThing)\n */\n\nStream.prototype.latest = function () {\n    var s = new Stream();\n    var _write = s.write;\n    s.pause = function () {\n        this.paused = true;\n        // do not force parent to checkBackpressure\n    };\n    s.write = function (x) {\n        if (_._isStreamError(x)) {\n            // pass errors straight through\n            _write.call(this, x);\n        }\n        else if (x === nil) {\n            _write.call(this, x);\n        }\n        else {\n            if (this.paused) {\n                this._incoming = this._incoming.filter(function (x) {\n                    // remove any existing values from buffer\n                    return _._isStreamError(x) || x === nil;\n                });\n                this._incoming.push(x);\n            }\n            else {\n                _write.call(this, x);\n            }\n        }\n        // never push back\n        return true;\n    };\n    this._addConsumer(s);\n    s.resume();\n    return s;\n};\nexposeMethod('latest');\n\n/**\n * Returns values from an Object as a Stream. Reads properties\n * lazily, so if you don't read from all keys on an object, not\n * all properties will be read from (may have an effect where getters\n * are used).\n *\n * @id values\n * @section Objects\n * @name _.values(obj)\n * @param {Object} obj - the object to return values from\n * @api public\n *\n * _.values({foo: 1, bar: 2, baz: 3})  // => 1, 2, 3\n */\n\n_.values = function (obj) {\n    return _.keys(obj).map(function (k) {\n        return obj[k];\n    });\n};\n\n/**\n * Returns keys from an Object as a Stream.\n *\n * @id keys\n * @section Objects\n * @name _.keys(obj)\n * @param {Object} obj - the object to return keys from\n * @api public\n *\n * _.keys({foo: 1, bar: 2, baz: 3})  // => 'foo', 'bar', 'baz'\n */\n\n_.keys = function (obj) {\n    var keys = [];\n    for (var k in obj) {\n        if (obj.hasOwnProperty(k)) {\n            keys.push(k);\n        }\n    }\n    return _(keys);\n};\n\n/**\n * Returns key/value pairs for an Object as a Stream. Reads properties\n * lazily, so if you don't read from all keys on an object, not\n * all properties will be read from (may have an effect where getters\n * are used).\n *\n * @id pairs\n * @section Objects\n * @name _.pairs(obj)\n * @param {Object} obj - the object to return key/value pairs from\n * @api public\n *\n * _.pairs({foo: 1, bar: 2})  // => ['foo', 1], ['bar', 2]\n */\n\n_.pairs = function (obj) {\n    return _.keys(obj).map(function (k) {\n        return [k, obj[k]];\n    });\n};\n\n/**\n * Extends one object with the properties of another. **Note:** The\n * arguments are in the reverse order of other libraries such as\n * underscore. This is so it follows the convention of other functions in\n * this library and so you can more meaningfully partially apply it.\n *\n * @id extend\n * @section Objects\n * @name _.extend(a, b)\n * @param {Object} a - the properties to extend b with\n * @param {Object} b - the original object to extend\n * @api public\n *\n * _.extend({name: 'bar'}, {name: 'foo', price: 20})\n * // => {name: 'bar', price: 20}\n *\n * // example of partial application\n * var publish = _.extend({published: true});\n *\n * publish({title: 'test post'})\n * // => {title: 'test post', published: true}\n */\n\n_.extend = _.curry(function (extensions, target) {\n    for (var k in extensions) {\n        if (extensions.hasOwnProperty(k)) {\n            target[k] = extensions[k];\n        }\n    }\n    return target;\n});\n\n/**\n * Returns a property from an object.\n *\n * @id get\n * @section Objects\n * @name _.get(prop, obj)\n * @param {String} prop - the property to return\n * @param {Object} obj - the object to read properties from\n * @api public\n *\n * var obj = {foo: 'bar', baz: 123};\n * _.get('foo', obj) // => 'bar'\n *\n * // making use of partial application\n * var posts = [\n *   {title: 'one'},\n *   {title: 'two'},\n *   {title: 'three'}\n * ];\n *\n * _(posts).map(_.get('title'))  // => 'one', 'two', 'three'\n */\n\n_.get = _.curry(function (prop, obj) {\n    return obj[prop];\n});\n\n/**\n * Updates a property on an object, returning the updated object.\n *\n * @id set\n * @section Objects\n * @name _.set(prop, value, obj)\n * @param {String} prop - the property to return\n * @param value - the value to set the property to\n * @param {Object} obj - the object to set properties on\n * @api public\n *\n * var obj = {foo: 'bar', baz: 123};\n * _.set('foo', 'wheeee', obj) // => {foo: 'wheeee', baz: 123}\n *\n * // making use of partial application\n * var publish = _.set('published', true);\n *\n * publish({title: 'example'})  // => {title: 'example', published: true}\n */\n\n_.set = _.curry(function (prop, val, obj) {\n    obj[prop] = val;\n    return obj;\n});\n\n/**\n * Logs values to the console, a simple wrapper around `console.log` that\n * it suitable for passing to other functions by reference without having to\n * call `bind`.\n *\n * @id log\n * @section Utils\n * @name _.log(args..)\n * @api public\n *\n * _.log('Hello, world!');\n *\n * _([1, 2, 3, 4]).each(_.log);\n */\n\n_.log = function () {\n    console.log.apply(console, arguments);\n};\n\n/**\n * Wraps a node-style async function which accepts a callback, transforming\n * it to a function which accepts the same arguments minus the callback and\n * returns a Highland Stream instead. Only the first argument to the\n * callback (or an error) will be pushed onto the Stream.\n *\n * @id wrapCallback\n * @section Utils\n * @name _.wrapCallback(f)\n * @param {Function} f - the node-style function to wrap\n * @api public\n *\n * var fs = require('fs');\n *\n * var readFile = _.wrapCallback(fs.readFile);\n *\n * readFile('example.txt').apply(function (data) {\n *     // data is now the contents of example.txt\n * });\n */\n\n_.wrapCallback = function (f) {\n    return function () {\n        var args = slice.call(arguments);\n        return _(function (push) {\n            var cb = function (err, x) {\n                if (err) {\n                    push(err);\n                }\n                else {\n                    push(null, x);\n                }\n                push(null, nil);\n            };\n            f.apply(null, args.concat([cb]));\n        });\n    };\n};\n\n/**\n * Add two values. Can be partially applied.\n *\n * @id add\n * @section Operators\n * @name _.add(a, b)\n * @api public\n *\n * add(1, 2) === 3\n * add(1)(5) === 6\n */\n\n_.add = _.curry(function (a, b) {\n    return a + b;\n});\n\n/**\n * Perform logical negation on a value. If `x` is truthy then returns false,\n * otherwise returns true.\n *\n * @id not\n * @section Operators\n * @name _.not(x)\n * @param x - the value to negate\n * @api public\n *\n * _.not(true)   // => false\n * _.not(false)  // => true\n */\n\n_.not = function (x) {\n    return !x;\n};\n", "module.exports = Object.create(new Proxy({}, {\n  get(_, key) {\n    if (\n      key !== '__esModule' &&\n      key !== '__proto__' &&\n      key !== 'constructor' &&\n      key !== 'splice'\n    ) {\n      console.warn(`Module \"url\" has been externalized for browser compatibility. Cannot access \"url.${key}\" in client code. See http://vitejs.dev/guide/troubleshooting.html#module-externalized-for-browser-compatibility for more details.`)\n    }\n  }\n}))", "(function(){\n  var σ, parseUrl, last, slice$ = [].slice;\n  σ = require('highland');\n  parseUrl = require('url').parse;\n  last = function(arg$){\n    var x;\n    x = arg$[arg$.length - 1];\n    return x;\n  };\n  exports.compilePath = function(path){\n    var ident, sigil, params, paramReg, reg;\n    ident = '[a-z$_][a-z0-9$_]*';\n    sigil = ':';\n    params = [];\n    paramReg = path.replace(RegExp(sigil + '(' + ident + ')', 'ig'), function(m, param){\n      params.push(param);\n      return '([^\\\\/]+)';\n    });\n    reg = (function(){\n      switch (false) {\n      case path !== '/':\n        return /^\\/$/;\n      case '/' !== last(path):\n        return RegExp('^' + paramReg + '?', 'i');\n      default:\n        return RegExp('^' + paramReg + '\\\\/?$', 'i');\n      }\n    }());\n    return function(url){\n      var pathname, that, route, vals, i, val;\n      pathname = parseUrl(url).pathname;\n      if ((that = reg.exec(pathname)) != null) {\n        route = that[0], vals = slice$.call(that, 1);\n        return σ([(function(){\n          var i$, ref$, len$, results$ = {};\n          for (i$ = 0, len$ = (ref$ = vals).length; i$ < len$; ++i$) {\n            i = i$;\n            val = ref$[i$];\n            results$[params[i]] = val;\n          }\n          return results$;\n        }())]);\n      } else {\n        return σ([]);\n      }\n    };\n  };\n}).call(this);\n", "(function(){\n  var compilePath, σ, guard, respond, i$, ref$, len$, m;\n  compilePath = require('./compiler').compilePath;\n  σ = require('highland');\n  guard = function(cond){\n    if (cond) {\n      return σ([null]);\n    } else {\n      return σ([]);\n    }\n  };\n  module.exports = respond = curry$(function(method, path, responder){\n    var lower, extract;\n    lower = method.toLowerCase();\n    extract = compilePath(path);\n    return function(request){\n      return guard(lower === request.method.toLowerCase()).flatMap(function(){\n        return extract(request.url).flatMap(function(params){\n          return responder((request.params = params, request.route = path, request));\n        });\n      });\n    };\n  });\n  for (i$ = 0, len$ = (ref$ = ['get', 'post', 'put', 'delete', 'patch', 'options', 'head', 'trace', 'connect']).length; i$ < len$; ++i$) {\n    m = ref$[i$];\n    module.exports[m] = respond(m);\n  }\n  /* istanbul ignore next */\n  function curry$(f, bound){\n    var context,\n    _curry = function(args) {\n      return f.length > 1 ? function(){\n        var params = args ? args.concat() : [];\n        context = bound ? context || this : this;\n        return params.push.apply(params, arguments) <\n            f.length && arguments.length ?\n          _curry.call(context, params) : f.apply(context, params);\n      } : f;\n    };\n    return _curry();\n  }\n}).call(this);\n", "(function(){\n  var σ;\n  σ = require('highland');\n  exports.route = curry$(function(fns, req){\n    return fns.reduce(function(acc, fn){\n      return acc.otherwise(fn(req));\n    }, σ([]));\n  });\n  /* istanbul ignore next */\n  function curry$(f, bound){\n    var context,\n    _curry = function(args) {\n      return f.length > 1 ? function(){\n        var params = args ? args.concat() : [];\n        context = bound ? context || this : this;\n        return params.push.apply(params, arguments) <\n            f.length && arguments.length ?\n          _curry.call(context, params) : f.apply(context, params);\n      } : f;\n    };\n    return _curry();\n  }\n}).call(this);\n", "(function(){\n  var ref$;\n  module.exports = (ref$ = {}, import$(ref$, require('./respond')), import$(ref$, require('./route')));\n  /* istanbul ignore next */\n  function import$(obj, src){\n    var own = {}.hasOwnProperty;\n    for (var key in src) if (own.call(src, key)) obj[key] = src[key];\n    return obj;\n  }\n}).call(this);\n"],
  "mappings": "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",
  "names": ["x", "err", "require_lib"]
}
